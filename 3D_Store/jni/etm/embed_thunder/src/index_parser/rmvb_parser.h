
#if !defined(__RMVB_PARSER_20090201)
#define __RMVB_PARSER_20090201

#ifdef __cplusplus
extern "C" 
{
#endif

#include "utility/define.h"
#include "utility/range.h"

#define RMFF_VERSION_MAJOR 0
#define RMFF_VERSION_MINOR 6
#define RMFF_VERSION_MICRO 2
#define RMFF_VERSION (RMFF_VERSION_MAJOR * 10000 + RMFF_VERSION_MINOR * 100 + \
                      RMFF_VERSION_MICRO)

/** \brief The stream may be saved to disc. Can be set in the
    \link ::rmff_prop_t PROP header\endlink. */
#define RMFF_FILE_FLAG_SAVE_ENABLED     0x0001
/** \brief Allows the client to use extra buffering. Can be set in the
    \link ::rmff_prop_t PROP header\endlink. */
#define RMFF_FILE_FLAG_PERFECT_PLAY     0x0002
/** \brief The stream is being generated by a live broadcast. Can be set in the
    \link ::rmff_prop_t PROP header\endlink. */
#define RMFF_FILE_FLAG_LIVE_BROADCAST   0x0004
/** \brief The stream may be downloaded. Can be set in the
    \link ::rmff_prop_t PROP header\endlink. */
#define RMFF_FILE_FLAG_DOWNLOAD_ENABLED 0x0008

/** \brief The common object handler. It precedes all the other headers.
 */
typedef struct rmff_object_t {
  /** \brief The object's id, e.g. \c 'PROP'. */
  _u32  id;
  /** \brief The size of this header including this object header. */
  _u32 size;
  /** \brief The version, usually 0. */
  _u16 version;
} rmff_object_t;

/** \brief The main file header. It is located at the very beginning of
    the file. */
typedef struct rmff_rmf_t {
  rmff_object_t obj;
  _u32 format_version;
  _u32 num_headers;
} rmff_rmf_t;

/** \brief The global PROP file header.

  This header is mandatory for a RealMedia file. It contains statistical
  and global data. The values are stored in big endian byte order.
  The application should use the functions ::rmff_get_uint16_be,
  ::rmff_get_uint32_be, ::rmff_put_uint16_be and
  ::rmff_put_uint32_be for accessing the members.
*/
typedef struct rmff_prop_t {
  rmff_object_t obj;
  _u32 max_bit_rate;
  _u32 avg_bit_rate;
  _u32 max_packet_size;
  _u32 avg_packet_size;
  _u32 num_packets;
  _u32 duration;
  _u32 preroll;
  _u32 index_offset;
  _u32 data_offset;
  _u16 num_streams;
  _u16 flags;
} rmff_prop_t;

/** \brief Comments about the file in question.

  This structure contains the parsed values of the CONT header. These
  strings must not be modified by the application. The function
  ::rmff_set_cont_header must be used instead.
*/
typedef struct rmff_cont_t {
  rmff_object_t obj;
  char *title;
  char *author;
  char *copyright;
  char *comment;
} rmff_cont_t;

/** \brief The MDPR track headers.

  Each track in a RealMedia file contains the MDPR header. The values
  are stored in big endian byte order.
  The application should use the functions ::rmff_get_uint16_be,
  ::rmff_get_uint32_be, ::rmff_put_uint16_be and
  ::rmff_put_uint32_be for accessing the members.
*/
typedef struct rmff_mdpr_t {
  rmff_object_t obj;
  /** \brief The track number. It is unique regarding the file. */
  _u16 id;
  /** \brief The maximum bitrate in bits/second.

    When creating a file this value will
    be updated automatically by the library. */
  _u32 max_bit_rate;
  /** \brief The average bitrate in bits/second.
    When creating a file this value will
    be updated automatically by the library. */
  _u32 avg_bit_rate;
  /** \brief The maximum packet size in bytes.

    When creating a file this value will
    be updated automatically by the library. */
  _u32 max_packet_size;
  /** \brief The average packet size in bytes.

    When creating a file this value will
    be updated automatically by the library. */
  _u32 avg_packet_size;
  _u32 start_time;
  _u32 preroll;
  _u32 duration;
  /** \brief The track's name.

    Use the ::rmff_set_track_data function for setting it. */
  char *name;
  /** \brief The track's MIME type.

    Use the ::rmff_set_track_data function for setting it. */
  char *mime_type;
  /** \brief The size of the track specific data in bytes. */
  _u32 type_specific_size;
  /** \brief Track type specific data.

    Use the ::rmff_set_type_specific_data function for setting it. It usually
    contains a ::real_video_props_t or ::real_audio_v4_props_t structure. */
  _u8 *type_specific_data;
} rmff_mdpr_t;

typedef struct  real_video_props_t {
  _u32 size;
  _u32 fourcc1;
  _u32 fourcc2;
  _u16 width;
  _u16 height;
  _u16 bpp;
  _u32 unknown1;
  _u32 fps;
  _u32 type1;
  _u32 type2;
} real_video_props_t;

typedef struct real_audio_v4_props_t {
  _u32 fourcc1;             /* '.', 'r', 'a', 0xfd */
  _u16 version1;            /* 4 or 5 */
  _u16 unknown1;            /* 00 00 */
  _u32 fourcc2;             /* .ra4 or .ra5 */
  _u32 stream_length;       /* ??? */
  _u16 version2;            /* 4 or 5 */
  _u32 header_size;         /* == 0x4e */
  _u16 flavor;              /* codec flavor id */
  _u32 coded_frame_size;    /* coded frame size */
  _u32 unknown3;            /* big number */
  _u32 unknown4;            /* bigger number */
  _u32 unknown5;            /* yet another number */
  _u16 sub_packet_h;
  _u16 frame_size;
  _u16 sub_packet_size;
  _u16 unknown6;            /* 00 00 */
  _u16 sample_rate;
  _u16 unknown8;            /* 0 */
  _u16 sample_size;
  _u16 channels;
} real_audio_v4_props_t;

typedef struct  real_audio_v5_props_t {
  _u32 fourcc1;             /* '.', 'r', 'a', 0xfd */
  _u16 version1;            /* 4 or 5 */
  _u16 unknown1;            /* 00 00 */
  _u32 fourcc2;             /* .ra4 or .ra5 */
  _u32 stream_length;       /* ??? */
  _u16 version2;            /* 4 or 5 */
  _u32 header_size;         /* == 0x4e */
  _u16 flavor;              /* codec flavor id */
  _u32 coded_frame_size;    /* coded frame size */
  _u32 unknown3;            /* big number */
  _u32 unknown4;            /* bigger number */
  _u32 unknown5;            /* yet another number */
  _u16 sub_packet_h;
  _u16 frame_size;
  _u16 sub_packet_size;
  _u16 unknown6;            /* 00 00 */
  _u8 unknown7[6];          /* 0, srate, 0 */
  _u16 sample_rate;
  _u16 unknown8;            /* 0 */
  _u16 sample_size;
  _u16 channels;
  _u32 genr;                /* "genr" */
  _u32 fourcc3;             /* fourcc */
} real_audio_v5_props_t;

typedef struct rmff_index_entry_t {
  _u32 pos;
  _u32 timecode;
  _u32 packet_number;
} rmff_index_entry_t;

/** \brief The packet is being delivered reliably. Can be set in the
    ::rmff_frame_t#flags member. */
#define RMFF_FRAME_FLAG_RELIABLE 0x01
/** \brief The frame is a key frame. Can be set in the ::rmff_frame_t#flags
    member. */
#define RMFF_FRAME_FLAG_KEYFRAME 0x02

/** A frame or packet of media data.

  A new frame can be obtained with ::rmff_allocate_frame or read from a file
  with ::rmff_read_next_frame. In both cases the application can either
  have \a librmff allocate a buffer for the frame contents or provide the
  buffer itself. In the latter case ::rmff_release_frame will not free the
  buffer either.

  \note The fields in this structure are stored in the machine's byte order
  which is little endian on x86 systems.
*/
typedef struct rmff_frame_t {
  /** \brief The frame/packet contents. */
  _u8 *data;
  /** \brief The number of bytes in this frame. */
  _u32 size;
  /** \brief Set by \a librmff if \a librmff has allocated the buffer and
      should free it in ::rmff_release_frame. */
  int allocated_by_rmff;

  /** \brief The track ID this frame belongs to. This will be overwritten
      in ::rmff_write_frame. */
  _u16 id;
  /** \brief The presentation timestamp in ms. */
  _u32 timecode;
  _u8 reserved;
  /** \brief Flags, e.g. bit 1 = key frame */
  _u8 flags;
} rmff_frame_t;

/** \brief Unknown track type. */
#define RMFF_TRACK_TYPE_UNKNOWN                        0
/** \brief The track contains audio data. */
#define RMFF_TRACK_TYPE_AUDIO                          1
/** \brief The track contains video data. */
#define RMFF_TRACK_TYPE_VIDEO                          2

struct rmff_file_t;

typedef struct rmff_track_t {
  _u32 id;
  int type;
  rmff_mdpr_t mdpr_header;

  rmff_index_entry_t *index;
  int num_index_entries;

  struct rmff_file_t *file;

  void *app_data;
  void *internal;
} rmff_track_t;

typedef struct rmff_file_t {
  void *handle;
  char *name;
  int open_mode;
  _int64 size;

  int headers_read;

  rmff_rmf_t rmf_header;
  rmff_prop_t prop_header;
  rmff_cont_t cont_header;
  int cont_header_present;
  _u32 num_packets_in_chunk;
  _u32 num_packets_read;

  rmff_track_t **tracks;
  int num_tracks;

  void *app_data;
  void *internal;
} RMFF_FILE_T;

/** \brief No error has occured. */
#define RMFF_ERR_OK                                   INDEX_PARSER_ERR_OK
/** \brief The file is not a valid RealMedia file. */
#define RMFF_ERR_NOT_RMFF                             INDEX_PARSER_ERR_NOT_RMFF
/** \brief The structures/data read from the file were invalid. */
#define RMFF_ERR_DATA                                 INDEX_PARSER_ERR_DATA
/** \brief The end of the file has been reached. */
#define RMFF_ERR_EOF                                  INDEX_PARSER_ERR_EOF
/** \brief An error occured during file I/O. */
#define RMFF_ERR_IO                                   INDEX_PARSER_ERR_IO
/** \brief The parameters were invalid. */
#define RMFF_ERR_PARAMETERS                           INDEX_PARSER_ERR_PARAMETERS
/** \brief An error has occured for which \c errno should be consulted. */
#define RMFF_ERR_CHECK_ERRNO                          INDEX_PARSER_ERR_CHECK_ERRNO

/** \brief Convert the four bytes into a 'FOURCC' uint32. */
#define rmffFOURCC(a, b, c, d) \
  (_u32)((((_u8)a) << 24) + \
  (((_u8)b) << 16) + \
  (((_u8)c) << 8) + \
  ((_u8)d))
	
typedef struct rmff_video_segment_t {
	_u32 size;
	_u32 offset;
	_u8 *data;
} rmff_video_segment_t;

typedef struct rmff_bitrate_t {
	_u32 *timecodes;
	_u32 *frame_sizes;
	_u32 num_entries;
} rmff_bitrate_t;

typedef struct rmff_file_internal_t {
	_u32 max_bit_rate;
	_u32 avg_bit_rate;
	_u32 max_packet_size;
	_u32 avg_packet_size;
	_u32 highest_timecode;
	_u32 num_packets;
	_u32 data_offset;
	_u32 next_data_offset;
	_u32 data_contents_size;
	_u32 index_offset;
	int num_index_chunks;
	_u32 total_bytes;
	rmff_bitrate_t bitrate;
} rmff_file_internal_t;

typedef struct rmff_track_internal_t {
	_u32 max_bit_rate;
	_u32 avg_bit_rate;
	_u32 max_packet_size;
	_u32 avg_packet_size;
	_u32 highest_timecode;
	_u32 num_packets;
	_u32 num_packed_frames;
	int index_this;
	_u32 total_bytes;
	rmff_bitrate_t bitrate;
	
	/* Used for video packet assembly. */
	_u32 c_timecode;
	int f_merged;
	int c_keyframe;
	rmff_video_segment_t *segments;
	int num_segments;
	rmff_frame_t **assembled_frames;
	int num_assembled_frames;
} rmff_track_internal_t;

_int32 rmff_read_headers(char* head_buffer, _int32 length, RMFF_FILE_T *file) ;
#ifdef __cplusplus
}
#endif

#endif /* !defined(___RMVB_PARSER_20090201)*/



